# -- Opening file external_input.aq21
# -- Done Parsing
x2 : 1, 2, 3, 
x3 : 1, 2, 
x4 : 1, 2, 3, 
# -- Number of Events: 10
# -- Number of Testing Events: 0
# Creating file 
# -- Output Generated by AQ21
Description
{

definition_filename = external_input.aq21


	Building rules for classes

}

(#  -- Debugging information 

The following information are required when submitting a bug.
They specify which version of the program was used.

$Id: aq21.cpp,v 1.9 2004/10/21 17:15:03 jwojt Exp $
$Id: AqLearner.cpp,v 1.22 2004/12/01 16:46:57 jwojt Exp $
$Id: BasicComplex.cpp,v 1.16 2004/12/01 16:46:57 jwojt Exp $
$Id: LEF.cpp,v 1.1.1.1 2003/06/18 21:07:23 jwojt Exp $
$Id: LEFCriterion.cpp,v 1.4 2004/10/05 20:59:04 jwojt Exp $
$Id: Domain.cpp,v 1.8 2004/11/29 21:56:10 jwojt Exp $
$Id: Attribute.cpp,v 1.8 2004/06/30 20:32:12 jwojt Exp $
$Id: Tests.cpp,v 1.13 2004/10/08 20:55:01 jwojt Exp $
$Id: CI.cpp,v 1.6 2004/10/21 17:15:03 jwojt Exp $

#)

domains
{
	class nominal  { 1, 2 }
	x2 continuous 
	x2_Discretized discretized continuous ranges [ 1, 2, 3 ]
	x3 continuous 
	x3_Discretized discretized continuous ranges [ 1, 2 ]
	x4 continuous 
	x4_Discretized discretized continuous ranges [ 1, 2, 3 ]
}


attributes
{
	class class epsilon = 0.5 cost = 1
	x3 x3 epsilon = 0.5 cost = 1
	x2 x2_Discretized epsilon = 0.5 cost = 1
	x3 x3_Discretized epsilon = 0.5 cost = 1
}


runs
{
 random_seed = 975313573

   rules_for_1
   {
     consequent = [class=1] 
     learn_rules_mode = standard

     maxstar = 2     maxrule = 5     ambiguity = IgnoreForLearning
     trim = Optimal
     exceptions = false

     mode = tf
     minimum_u = 1

     optimize_ruleset = true
     continuous_optimization_probe = 5

     truncate = true
     display_selectors_coverage = false
     display_values_coverage = false
     display_events_covered = true
     display_alternative_covers = false
   attribute_selection_method = none
     handling_unknown_values = program_selected_method

     LEF_star
     {
         MaxNewPositives, 0.3  
         MinNumSelectors, 0.3  
         MinComplexity, 0.3  
         MinCost, 0.3  
     }

     LEF_partial_star
     {
         MaxNewPositives, 0  
         MinNumSelectors, 0  
         MinComplexity, 0  
         MinCost, 0  
     }

     LEF_sort
     {         
         MaxPositives, 0  
     }

   }

   rules_for_2
   {
     consequent = [class=2] 
     learn_rules_mode = standard

     maxstar = 2     maxrule = 5     ambiguity = IgnoreForLearning
     trim = Optimal
     exceptions = false

     mode = tf
     minimum_u = 1

     optimize_ruleset = true
     continuous_optimization_probe = 5

     truncate = true
     display_selectors_coverage = false
     display_values_coverage = false
     display_events_covered = true
     display_alternative_covers = false
   attribute_selection_method = none
     handling_unknown_values = program_selected_method

     LEF_star
     {
         MaxNewPositives, 0.3  
         MinNumSelectors, 0.3  
         MinComplexity, 0.3  
         MinCost, 0.3  
     }

     LEF_partial_star
     {
         MaxNewPositives, 0  
         MinNumSelectors, 0  
         MinComplexity, 0  
         MinCost, 0  
     }

     LEF_sort
     {         
         MaxPositives, 0  
     }

   }

}


Output_Hypotheses rules_for_1
{
  # -- This learning took = 
  # -- System (CPU) time  = 0
  # -- User (Total) time  = 0
  # -- Number of rules in the cover = 2
  # -- Number of conditions         = 1
  # -- Complexity for this cover    = 7
  # -- Average number of rules kept from each stars = 2
  # -- Uncovered Positives = 0

  positive_events           = 4
  negative_events           = 6
[class=1] 
       # Rule 1
   <--  : p=2,np=2,enp=2,n=2,en=2,u=2,cx=0,c=1,s=2 # 33

         covered_positives
         # number of distinct covered positives = 2
         {
         1, 1, 1.500000, *, 1.500000,     1, 1, 1
         1, 1, 1.500000, *, 2.500000,     1, 1, 3
         }

         covered_negatives
         # number of distinct covered negatives = 2
         {
         2, 1, 1.500000, *, ?,     1, 1, 7
         2, 2, 1.500000, ?, ?,     1, 1, 6
         }


       # Rule 2
   <-- [x4=1.000000..1.999900]
        : p=2,np=2,u=2,cx=7,c=1,s=2 # 34

         covered_positives
         # number of distinct covered positives = 2
         {
         1, 1, 2.500000, *, 1.500000,     1, 1, 4
         1, 2, 2.500000, ?, 1.500000,     1, 1, 2
         }



}

Output_Hypotheses rules_for_2
{
  # -- This learning took = 
  # -- System (CPU) time  = 0
  # -- User (Total) time  = 0
  # -- Number of rules in the cover = 3
  # -- Number of conditions         = 2
  # -- Complexity for this cover    = 14
  # -- Average number of rules kept from each stars = 1.667
  # -- Uncovered Positives = 0

  positive_events           = 6
  negative_events           = 4
[class=2] 
       # Rule 1
   <-- [x2=2.000000..2.999900]
       [x4=2.000000..2.999900]
        : p=3,np=2,u=2,cx=14,c=1,s=3 # 64

         covered_positives
         # number of distinct covered positives = 3
         {
         2, 1, 2.500000, *, 2.500000,     1, 1, 10
         2, 1, ?, *, ?,     1, 1, 8
         2, 2, 2.500000, ?, 2.500000,     1, 1, 5
         }


       # Rule 2
   <--  : p=2,np=2,u=2,cx=0,c=1,s=2 # 65

         covered_positives
         # number of distinct covered positives = 2
         {
         2, 1, 1.500000, *, ?,     1, 1, 7
         2, 2, 1.500000, ?, ?,     1, 1, 6
         }

         covered_negatives
         # number of distinct covered negatives = 2
         {
         1, 1, 1.500000, *, 1.500000,     1, 1, 1
         1, 1, 1.500000, *, 2.500000,     1, 1, 3
         }


       # Rule 3
   <--  : p=2,np=2,u=1,cx=0,c=1,s=2 # 66

         covered_positives
         # number of distinct covered positives = 2
         {
         2, 1, ?, *, 1.500000,     1, 1, 9
         2, 1, ?, *, ?,     1, 1, 8
         }



}

